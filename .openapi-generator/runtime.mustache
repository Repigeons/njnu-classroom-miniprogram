/* tslint:disable */
/* eslint-disable */
{{>licenseInfo}}

export interface Response {
  statusCode: number;
  header: TaroGeneral.IAnyObject;
  data: any;
}

export class BaseAPI {
  constructor(public basePath: string) {}
  protected configuration = {
    apiKey: (name: string) => wx.getStorageSync(name)
  }
  protected async uploadFile(context: RequestOpts): Promise<Response> {
    const data = context.body
    return new Promise((resolve, reject) => {
      wx.uploadFile({
        url: this.basePath + context.path,
        name: data.keys[0],
        filePath: data[data.keys[0]],
        success: res => resolve({
          statusCode: res.statusCode,
          header: {},
          data: res.data
        }),
        fail: reject,
      });
    });
  }

  protected async request(context: RequestOpts): Promise<Response> {
    const { url, init } = this.createFetchParams(context);
    return new Promise((resolve, reject) => {
      wx.request({
        method: init.method as "GET" | "POST" | "PUT" | "DELETE" | "OPTIONS" | "HEAD" | "TRACE" | "CONNECT" | undefined,
        url: url,
        header: init.headers,
        data: init.body,
        success: resolve,
        fail: reject,
        enableHttp2: true,
        enableQuic: true,
      });
    });
  }

  private createFetchParams(context: RequestOpts) {
    let url = this.basePath + context.path;
    if (
      context.query !== undefined &&
      Object.keys(context.query).length !== 0
    ) {
      let queryString = "";
      for (const key in context.query) {
        queryString += `&${key}=${context.query[key]}`;
      }
      url += "?" + queryString.substring(1);
    }
    const body = JSON.stringify(context.body);
//      (typeof FormData !== "undefined" && context.body instanceof FormData) ||
//      context.body instanceof URLSearchParams
//        ? context.body
//        : JSON.stringify(context.body);

    const init = {
      method: context.method,
      headers: context.headers,
      body,
    };
    return { url, init };
  }
}
export interface RequestOpts {
  path: string;
  method: HTTPMethod;
  headers: HTTPHeaders;
  query?: HTTPQuery;
  body?: HTTPBody;
}
export type Json = any;
export type HTTPMethod =
  | "GET"
  | "POST"
  | "PUT"
  | "PATCH"
  | "DELETE"
  | "OPTIONS"
  | "HEAD";
export type HTTPHeaders = { [key: string]: string };
export type HTTPQuery = {
  [key: string]:
    | string
    | number
    | null
    | boolean
    | Array<string | number | null | boolean>
    | HTTPQuery;
};
export type HTTPBody = Json; //| FormData | URLSearchParams;

export class RequiredError extends Error {
  name: "RequiredError" = "RequiredError";
  constructor(public field: string, msg?: string) {
    super(msg);
  }
}

export interface ApiResponse<T> {
  raw: Response;
  value(): Promise<T>;
}
export class JSONApiResponse<T> {
  constructor(
    public raw: Response,
    private transformer: ResponseTransformer<T> = (jsonValue: any) => jsonValue
  ) {}

  async value(): Promise<T> {
    if (this.raw.statusCode >= 200 && this.raw.statusCode < 300) {
      return this.transformer(this.raw.data);
    } else {
        throw this.raw
    }
  }
}
export interface ResponseTransformer<T> {
  (json: any): T;
}


export function mapValues(data: any, fn: (item: any) => any) {
  return Object.keys(data).reduce(
    (acc, key) => ({ ...acc, [key]: fn(data[key]) }),
    {}
  );
}
export function exists(json: any, key: string) {
  const value = json[key];
  return value !== null && value !== undefined;
}

export function querystring(params: HTTPQuery, prefix: string = ""): string {
  return Object.keys(params)
    .map((key) => {
      const fullKey = prefix + (prefix.length ? `[${key}]` : key);
      const value = params[key];
      if (value instanceof Array) {
        const multiValue = value
          .map((singleValue) => encodeURIComponent(String(singleValue)))
          .join(`&${encodeURIComponent(fullKey)}=`);
        return `${encodeURIComponent(fullKey)}=${multiValue}`;
      }
      if (value instanceof Object) {
        return querystring(value as HTTPQuery, fullKey);
      }
      return `${encodeURIComponent(fullKey)}=${encodeURIComponent(
        String(value)
      )}`;
    })
    .filter((part) => part.length > 0)
    .join("&");
}

export interface Consume {
    contentType: string;
}

export function canConsumeForm(consumes: { contentType: string }[]): boolean {
  return consumes.find((consume) => consume.contentType == "multipart/form-data") != undefined;
}
